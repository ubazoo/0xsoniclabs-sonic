// Copyright 2025 Sonic Operations Ltd
// This file is part of the Sonic Client
//
// Sonic is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Sonic is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with Sonic. If not, see <http://www.gnu.org/licenses/>.

// Code generated by MockGen. DO NOT EDIT.
// Source: logger.go
//
// Generated by this command:
//
//	mockgen -source=logger.go -destination=logger_mock.go -package=logger
//

// Package logger is a generated GoMock package.
package logger

import (
	context "context"
	slog "log/slog"
	reflect "reflect"

	log "github.com/ethereum/go-ethereum/log"
	gomock "go.uber.org/mock/gomock"
)

// MockLogger is a mock of Logger interface.
type MockLogger struct {
	ctrl     *gomock.Controller
	recorder *MockLoggerMockRecorder
}

// MockLoggerMockRecorder is the mock recorder for MockLogger.
type MockLoggerMockRecorder struct {
	mock *MockLogger
}

// NewMockLogger creates a new mock instance.
func NewMockLogger(ctrl *gomock.Controller) *MockLogger {
	mock := &MockLogger{ctrl: ctrl}
	mock.recorder = &MockLoggerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLogger) EXPECT() *MockLoggerMockRecorder {
	return m.recorder
}

// Crit mocks base method.
func (m *MockLogger) Crit(msg string, ctx ...any) {
	m.ctrl.T.Helper()
	varargs := []any{msg}
	for _, a := range ctx {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Crit", varargs...)
}

// Crit indicates an expected call of Crit.
func (mr *MockLoggerMockRecorder) Crit(msg any, ctx ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{msg}, ctx...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Crit", reflect.TypeOf((*MockLogger)(nil).Crit), varargs...)
}

// Debug mocks base method.
func (m *MockLogger) Debug(msg string, ctx ...any) {
	m.ctrl.T.Helper()
	varargs := []any{msg}
	for _, a := range ctx {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Debug", varargs...)
}

// Debug indicates an expected call of Debug.
func (mr *MockLoggerMockRecorder) Debug(msg any, ctx ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{msg}, ctx...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Debug", reflect.TypeOf((*MockLogger)(nil).Debug), varargs...)
}

// Enabled mocks base method.
func (m *MockLogger) Enabled(ctx context.Context, level slog.Level) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Enabled", ctx, level)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Enabled indicates an expected call of Enabled.
func (mr *MockLoggerMockRecorder) Enabled(ctx, level any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Enabled", reflect.TypeOf((*MockLogger)(nil).Enabled), ctx, level)
}

// Error mocks base method.
func (m *MockLogger) Error(msg string, ctx ...any) {
	m.ctrl.T.Helper()
	varargs := []any{msg}
	for _, a := range ctx {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Error", varargs...)
}

// Error indicates an expected call of Error.
func (mr *MockLoggerMockRecorder) Error(msg any, ctx ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{msg}, ctx...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockLogger)(nil).Error), varargs...)
}

// Handler mocks base method.
func (m *MockLogger) Handler() slog.Handler {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Handler")
	ret0, _ := ret[0].(slog.Handler)
	return ret0
}

// Handler indicates an expected call of Handler.
func (mr *MockLoggerMockRecorder) Handler() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Handler", reflect.TypeOf((*MockLogger)(nil).Handler))
}

// Info mocks base method.
func (m *MockLogger) Info(msg string, ctx ...any) {
	m.ctrl.T.Helper()
	varargs := []any{msg}
	for _, a := range ctx {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Info", varargs...)
}

// Info indicates an expected call of Info.
func (mr *MockLoggerMockRecorder) Info(msg any, ctx ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{msg}, ctx...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockLogger)(nil).Info), varargs...)
}

// Log mocks base method.
func (m *MockLogger) Log(level slog.Level, msg string, ctx ...any) {
	m.ctrl.T.Helper()
	varargs := []any{level, msg}
	for _, a := range ctx {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Log", varargs...)
}

// Log indicates an expected call of Log.
func (mr *MockLoggerMockRecorder) Log(level, msg any, ctx ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{level, msg}, ctx...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockLogger)(nil).Log), varargs...)
}

// New mocks base method.
func (m *MockLogger) New(ctx ...any) log.Logger {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range ctx {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "New", varargs...)
	ret0, _ := ret[0].(log.Logger)
	return ret0
}

// New indicates an expected call of New.
func (mr *MockLoggerMockRecorder) New(ctx ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "New", reflect.TypeOf((*MockLogger)(nil).New), ctx...)
}

// Trace mocks base method.
func (m *MockLogger) Trace(msg string, ctx ...any) {
	m.ctrl.T.Helper()
	varargs := []any{msg}
	for _, a := range ctx {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Trace", varargs...)
}

// Trace indicates an expected call of Trace.
func (mr *MockLoggerMockRecorder) Trace(msg any, ctx ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{msg}, ctx...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Trace", reflect.TypeOf((*MockLogger)(nil).Trace), varargs...)
}

// Warn mocks base method.
func (m *MockLogger) Warn(msg string, ctx ...any) {
	m.ctrl.T.Helper()
	varargs := []any{msg}
	for _, a := range ctx {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Warn", varargs...)
}

// Warn indicates an expected call of Warn.
func (mr *MockLoggerMockRecorder) Warn(msg any, ctx ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{msg}, ctx...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Warn", reflect.TypeOf((*MockLogger)(nil).Warn), varargs...)
}

// With mocks base method.
func (m *MockLogger) With(ctx ...any) log.Logger {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range ctx {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "With", varargs...)
	ret0, _ := ret[0].(log.Logger)
	return ret0
}

// With indicates an expected call of With.
func (mr *MockLoggerMockRecorder) With(ctx ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "With", reflect.TypeOf((*MockLogger)(nil).With), ctx...)
}

// Write mocks base method.
func (m *MockLogger) Write(level slog.Level, msg string, attrs ...any) {
	m.ctrl.T.Helper()
	varargs := []any{level, msg}
	for _, a := range attrs {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Write", varargs...)
}

// Write indicates an expected call of Write.
func (mr *MockLoggerMockRecorder) Write(level, msg any, attrs ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{level, msg}, attrs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockLogger)(nil).Write), varargs...)
}
