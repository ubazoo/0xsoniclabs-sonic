// Copyright 2025 Sonic Operations Ltd
// This file is part of the Sonic Client
//
// Sonic is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Sonic is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with Sonic. If not, see <http://www.gnu.org/licenses/>.

package ethapi

import (
	"context"
	"encoding/binary"
	"fmt"
	"hash/crc32"
	"maps"
	"math/big"
	"testing"

	"github.com/0xsoniclabs/sonic/evmcore"
	"github.com/0xsoniclabs/sonic/gossip/blockproc/subsidies/registry"
	"github.com/0xsoniclabs/sonic/inter"
	"github.com/0xsoniclabs/sonic/opera"
	"github.com/Fantom-foundation/lachesis-base/inter/idx"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/params"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/ethereum/go-ethereum/rpc"
	"github.com/stretchr/testify/require"
	"go.uber.org/mock/gomock"
)

func TestForkId_FollowsFormula(t *testing.T) {
	// this test verifies that the ForkId generated by MakeForkId follows the formula:
	// CRC32(genesisId || bigEndian(upgrade.Height) || Rlp(upgrade))

	upgradeHeights := map[string]opera.Upgrades{
		"sonic":   opera.GetSonicUpgrades(),
		"allegro": opera.GetAllegroUpgrades(),
		"brio":    opera.GetBrioUpgrades(),
	}
	blockHeights := []idx.Block{1, 5, 10}
	genesisHashes := []common.Hash{{0x42}, {0x43}, {0x44}}
	for name, upgrades := range upgradeHeights {
		for _, blockHeight := range blockHeights {
			for _, genesisHash := range genesisHashes {
				t.Run(fmt.Sprintf("%s-%v-%s", name, blockHeight, genesisHash.String()),
					func(t *testing.T) {

						// Calculate expected ForkId
						updateRlp, err := rlp.EncodeToBytes(upgrades)
						require.NoError(t, err, "rlp encoding failed")
						var blockNumberBytes [8]byte
						binary.BigEndian.PutUint64(blockNumberBytes[:], uint64(blockHeight))

						checkSum := crc32.ChecksumIEEE(genesisHash.Bytes())
						checkSum = crc32.Update(checkSum, crc32.IEEETable, blockNumberBytes[:])
						checkSum = crc32.Update(checkSum, crc32.IEEETable, updateRlp)

						var expectedForkId forkId
						binary.BigEndian.PutUint32(expectedForkId[:], checkSum)

						// Get ForkId from MakeForkId.
						gotForkId, err := MakeForkId(
							opera.MakeUpgradeHeight(upgrades, blockHeight),
							genesisHash)
						require.NoError(t, err, "makeForkId failed")

						require.Equal(t, expectedForkId, gotForkId,
							"fork ID does not follow the expected formula")
					},
				)
			}
		}
	}
}

func TestForkId_UpgradesProduceDifferentIds(t *testing.T) {
	tests := map[string]struct {
		upgradesHeight opera.UpgradeHeight
		want           forkId
	}{
		"Sonic": {
			upgradesHeight: opera.MakeUpgradeHeight(opera.GetSonicUpgrades(), 1),
			want:           forkId{0x75, 0x45, 0xd7, 0x6e},
		},
		"Allegro": {
			upgradesHeight: opera.MakeUpgradeHeight(opera.GetAllegroUpgrades(), 5),
			want:           forkId{0x6f, 0xfb, 0x6f, 0xd6},
		},
		"Brio": {
			upgradesHeight: opera.MakeUpgradeHeight(opera.GetBrioUpgrades(), 10),
			want:           forkId{0x12, 0x7b, 0x69, 0x7b},
		},
		// In a real case scenario, SingleProposer and GasSubsidies would be
		// turned on while another upgrade is activated, so we check that the
		// ForkId reflects these changes.
		"Sonic+SingleProposer": {
			upgradesHeight: func() opera.UpgradeHeight {
				upgrades := opera.GetSonicUpgrades()
				upgrades.SingleProposerBlockFormation = true
				return opera.MakeUpgradeHeight(upgrades, 1)
			}(),
			want: forkId{0x28, 0x66, 0x84, 0x67},
		},
		"Allegro+GasSubsidies": {
			upgradesHeight: func() opera.UpgradeHeight {
				upgrades := opera.GetAllegroUpgrades()
				upgrades.GasSubsidies = true
				return opera.MakeUpgradeHeight(upgrades, 5)
			}(),
			want: forkId{0xff, 0xae, 0xa0, 0xb6},
		},
	}

	genesisHash := common.Hash{0x42}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			got, err := MakeForkId(test.upgradesHeight, genesisHash)
			require.NoError(t, err, "makeForkHash failed")
			require.Equal(t, test.want, got, "unexpected fork hash")
		})
	}
}

func TestForkId_ProducesDifferentIds_ForDifferentGenesis(t *testing.T) {

	sonicUpgrades := opera.MakeUpgradeHeight(opera.GetSonicUpgrades(), 1)

	tests := map[string]struct {
		genesisId common.Hash
		want      forkId
	}{
		"GenesisA": {
			genesisId: common.Hash{0x42},
			want:      forkId{0x75, 0x45, 0xd7, 0x6e},
		},
		"GenesisB": {
			genesisId: common.Hash{0x43},
			want:      forkId{0xd4, 0x7c, 0x53, 0x80},
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			got, err := MakeForkId(sonicUpgrades, test.genesisId)
			require.NoError(t, err, "makeForkHash failed")
			require.Equal(t, test.want, got, "unexpected fork hash")
		})
	}
}

func TestMakeConfigFromUpgrade_Reports_AvailableSystemContracts(t *testing.T) {

	sonicHeight := idx.Block(1)
	allegroHeight := idx.Block(5)
	gasSubsidiesHeight := idx.Block(10)

	tests := map[string]struct {
		upgradeHeight    opera.UpgradeHeight
		wantSysContracts contractRegistry
	}{
		"Sonic": {
			upgradeHeight: opera.UpgradeHeight{
				Upgrades: opera.GetSonicUpgrades(),
				Height:   sonicHeight,
			},
			wantSysContracts: contractRegistry{},
		},
		"Allegro": {
			upgradeHeight: opera.UpgradeHeight{
				Upgrades: opera.GetAllegroUpgrades(),
				Height:   allegroHeight,
			},
			wantSysContracts: contractRegistry{"HISTORY_STORAGE_ADDRESS": params.HistoryStorageAddress},
		},
		"GasSubsidies": {
			upgradeHeight: opera.UpgradeHeight{
				Upgrades: func() opera.Upgrades {
					return opera.Upgrades{GasSubsidies: true}
				}(),
				Height: gasSubsidiesHeight,
			},
			wantSysContracts: contractRegistry{"GAS_SUBSIDY_REGISTRY_ADDRESS": registry.GetAddress()},
		},
		"Sonic+GasSubsidies": {
			upgradeHeight: opera.UpgradeHeight{
				Upgrades: func() opera.Upgrades {
					upgrades := opera.GetSonicUpgrades()
					upgrades.GasSubsidies = true
					return upgrades
				}(),
				Height: gasSubsidiesHeight,
			},
			wantSysContracts: contractRegistry{"GAS_SUBSIDY_REGISTRY_ADDRESS": registry.GetAddress()},
		},
		"Allegro+GasSubsidies": {
			upgradeHeight: opera.UpgradeHeight{
				Upgrades: func() opera.Upgrades {
					upgrades := opera.GetAllegroUpgrades()
					upgrades.GasSubsidies = true
					return upgrades
				}(),
				Height: gasSubsidiesHeight,
			},
			wantSysContracts: contractRegistry{
				"HISTORY_STORAGE_ADDRESS":      params.HistoryStorageAddress,
				"GAS_SUBSIDY_REGISTRY_ADDRESS": registry.GetAddress(),
			},
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			chainId := big.NewInt(250)
			chainCfg := opera.CreateTransientEvmChainConfig(
				chainId.Uint64(),
				[]opera.UpgradeHeight{test.upgradeHeight},
				test.upgradeHeight.Height,
			)

			ctrl := gomock.NewController(t)
			backend := NewMockBackend(ctrl)
			backend.EXPECT().ChainID().Return(chainId)
			backend.EXPECT().ChainConfig(gomock.Any()).Return(chainCfg)
			backend.EXPECT().GetGenesisID().Return(common.Hash{0x42})
			backend.EXPECT().BlockByNumber(gomock.Any(), rpc.BlockNumber(int64(test.upgradeHeight.Height))).
				Return(&evmcore.EvmBlock{EvmHeader: evmcore.EvmHeader{Time: inter.Timestamp(1)}}, nil)

			result, err := makeConfigFromUpgrade(context.Background(), backend, test.upgradeHeight)
			require.NoError(t, err, "unexpected error from makeConfigFromUpgrade")

			require.Equal(t, test.wantSysContracts, result.SystemContracts,
				"unexpected system contracts")
		})
	}
}

func TestMakeConfigFromUpgrade_ReportsErrors_WhenBlockByNumberReturnsAnError(t *testing.T) {
	ctrl := gomock.NewController(t)
	backend := NewMockBackend(ctrl)

	chainId := big.NewInt(250)
	backend.EXPECT().ChainID().Return(chainId)
	chainCfg := opera.CreateTransientEvmChainConfig(
		chainId.Uint64(),
		[]opera.UpgradeHeight{{}},
		0,
	)
	backend.EXPECT().ChainConfig(gomock.Any()).Return(chainCfg)
	backend.EXPECT().GetGenesisID().Return(common.Hash{0x42})

	backend.EXPECT().BlockByNumber(gomock.Any(), rpc.BlockNumber(int64(0))).
		Return(nil, fmt.Errorf("some error"))

	_, err := makeConfigFromUpgrade(t.Context(), backend, opera.UpgradeHeight{})
	require.ErrorContains(t, err, "could not get block")
}

func TestMakeConfigFromUpgrade_ReportsError_WhenBlockByNumberReturnsNilBlock(t *testing.T) {
	ctrl := gomock.NewController(t)
	backend := NewMockBackend(ctrl)

	chainId := big.NewInt(250)
	backend.EXPECT().ChainID().Return(chainId)
	chainCfg := opera.CreateTransientEvmChainConfig(
		chainId.Uint64(),
		[]opera.UpgradeHeight{{}},
		0,
	)
	backend.EXPECT().ChainConfig(gomock.Any()).Return(chainCfg)
	backend.EXPECT().GetGenesisID().Return(common.Hash{0x42})

	backend.EXPECT().BlockByNumber(gomock.Any(), rpc.BlockNumber(int64(0))).
		Return(nil, nil)

	_, err := makeConfigFromUpgrade(t.Context(), backend, opera.UpgradeHeight{})
	require.ErrorContains(t, err, "block 0 not found")
}

func TestEIP7910_Config_ReportsErrors(t *testing.T) {

	currentBlock := evmcore.EvmBlock{
		EvmHeader: evmcore.EvmHeader{
			Number: big.NewInt(5),
		},
	}

	tests := map[string]struct {
		backendSetup func(*MockBackend)
		expectedErr  string
	}{
		"fails to get current block": {
			backendSetup: func(mockBackend *MockBackend) {
				mockBackend.EXPECT().CurrentBlock().Return(nil)
			},
			expectedErr: "current block header not found",
		},
		"fails to get upgrade heights for current block": {
			backendSetup: func(mockBackend *MockBackend) {
				mockBackend.EXPECT().CurrentBlock().Return(&currentBlock)
				mockBackend.EXPECT().GetUpgradeHeights().Return(nil)
			},
			expectedErr: "no configs found",
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			backend := NewMockBackend(ctrl)

			test.backendSetup(backend)

			api := NewPublicBlockChainAPI(backend)
			_, err := api.Config(context.Background())
			require.Error(t, err)
			require.Contains(t, err.Error(), test.expectedErr)
		})
	}
}

func TestEIP7910_Config_ReturnsConfigs(t *testing.T) {

	chainId := big.NewInt(250)
	currentBlock := evmcore.EvmBlock{
		EvmHeader: evmcore.EvmHeader{
			Number: big.NewInt(5),
		},
	}

	sonicPrecompiled := contractRegistry{
		"BLAKE2F":              common.BytesToAddress([]byte{0x09}),
		"BN254_ADD":            common.BytesToAddress([]byte{0x06}),
		"BN254_MUL":            common.BytesToAddress([]byte{0x07}),
		"BN254_PAIRING":        common.BytesToAddress([]byte{0x08}),
		"ECREC":                common.BytesToAddress([]byte{0x01}),
		"ID":                   common.BytesToAddress([]byte{0x04}),
		"KZG_POINT_EVALUATION": common.BytesToAddress([]byte{0x0A}),
		"MODEXP":               common.BytesToAddress([]byte{0x05}),
		"RIPEMD160":            common.BytesToAddress([]byte{0x03}),
		"SHA256":               common.BytesToAddress([]byte{0x02}),
	}

	allegroPrecompiled := maps.Clone(sonicPrecompiled)
	allegroPrecompiled["BLS12_G1ADD"] = common.BytesToAddress([]byte{0x0B})
	allegroPrecompiled["BLS12_G1MSM"] = common.BytesToAddress([]byte{0x0C})
	allegroPrecompiled["BLS12_G2ADD"] = common.BytesToAddress([]byte{0x0D})
	allegroPrecompiled["BLS12_G2MSM"] = common.BytesToAddress([]byte{0x0E})
	allegroPrecompiled["BLS12_PAIRING_CHECK"] = common.BytesToAddress([]byte{0x0F})
	allegroPrecompiled["BLS12_MAP_FP_TO_G1"] = common.BytesToAddress([]byte{0x10})
	allegroPrecompiled["BLS12_MAP_FP2_TO_G2"] = common.BytesToAddress([]byte{0x11})

	tests := map[string]struct {
		backendSetup func(*MockBackend)
		wantConfig   configResponse
	}{
		"only current block config": {
			backendSetup: func(mockBackend *MockBackend) {
				mockBackend.EXPECT().CurrentBlock().Return(&currentBlock)
				upgradeHeights := []opera.UpgradeHeight{
					{
						Upgrades: opera.GetSonicUpgrades(),
						Height:   idx.Block(1),
					},
				}
				mockBackend.EXPECT().GetUpgradeHeights().Return(upgradeHeights)
				chainConfig := opera.CreateTransientEvmChainConfig(
					chainId.Uint64(),
					upgradeHeights,
					idx.Block(currentBlock.Number.Uint64()),
				)
				mockBackend.EXPECT().ChainConfig(gomock.Any()).Return(chainConfig)

			},
			wantConfig: func() configResponse {
				sonicId, err := MakeForkId(opera.MakeUpgradeHeight(opera.GetSonicUpgrades(), 1), common.Hash{0x42})
				require.NoError(t, err, "makeForkId failed for sonic upgrades")
				return configResponse{Current: &config{
					ChainId:         (*hexutil.Big)(chainId),
					ForkId:          sonicId[:],
					Precompiles:     sonicPrecompiled,
					SystemContracts: activeSystemContracts(opera.GetSonicUpgrades()),
				},
				}
			}(),
		},
		"current and last block configs": {
			backendSetup: func(mockBackend *MockBackend) {
				mockBackend.EXPECT().CurrentBlock().Return(&currentBlock)
				upgradeHeights := []opera.UpgradeHeight{
					{
						Upgrades: opera.GetSonicUpgrades(),
						Height:   idx.Block(1),
					},
					{
						Upgrades: opera.GetAllegroUpgrades(),
						Height:   idx.Block(5),
					},
				}
				mockBackend.EXPECT().GetUpgradeHeights().Return(upgradeHeights)
				currentChainConfig := opera.CreateTransientEvmChainConfig(
					chainId.Uint64(),
					upgradeHeights,
					idx.Block(5),
				)
				mockBackend.EXPECT().ChainConfig(idx.Block(5)).Return(currentChainConfig)
				lastChainConfig := opera.CreateTransientEvmChainConfig(
					chainId.Uint64(),
					upgradeHeights,
					idx.Block(1),
				)
				mockBackend.EXPECT().ChainConfig(idx.Block(1)).Return(lastChainConfig)

			},
			wantConfig: func() configResponse {
				sonicId, err := MakeForkId(opera.MakeUpgradeHeight(opera.GetSonicUpgrades(), 1), common.Hash{0x42})
				require.NoError(t, err, "makeForkId failed for sonic upgrades")

				allegroId, err := MakeForkId(opera.MakeUpgradeHeight(opera.GetAllegroUpgrades(), 5), common.Hash{0x42})
				require.NoError(t, err, "makeForkId failed for allegro upgrades")

				return configResponse{
					Current: &config{
						ChainId:         (*hexutil.Big)(chainId),
						ForkId:          allegroId[:],
						Precompiles:     allegroPrecompiled,
						SystemContracts: activeSystemContracts(opera.GetAllegroUpgrades()),
					},
					Last: &config{
						ChainId:         (*hexutil.Big)(chainId),
						ForkId:          sonicId[:],
						Precompiles:     sonicPrecompiled,
						SystemContracts: activeSystemContracts(opera.GetSonicUpgrades()),
					},
				}
			}(),
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			backend := NewMockBackend(ctrl)
			backend.EXPECT().ChainID().Return(chainId).AnyTimes()
			// could be called once or twice depending on the test case.
			backend.EXPECT().GetGenesisID().Return(common.Hash{0x42}).AnyTimes()
			backend.EXPECT().BlockByNumber(gomock.Any(), gomock.Any()).
				Return(&evmcore.EvmBlock{EvmHeader: evmcore.EvmHeader{Time: inter.Timestamp(1)}}, nil).AnyTimes()

			test.backendSetup(backend)

			api := NewPublicBlockChainAPI(backend)
			gotConfig, err := api.Config(context.Background())

			require.NoError(t, err)
			require.Equal(t, test.wantConfig, *gotConfig)
		})
	}
}
